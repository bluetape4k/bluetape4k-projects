package io.bluetape4k.hibernate.mapping.inheritance

import io.bluetape4k.ToStringBuilder
import io.bluetape4k.hibernate.AbstractHibernateTest
import io.bluetape4k.hibernate.model.IntJpaEntity
import io.bluetape4k.logging.KLogging
import io.bluetape4k.support.uninitialized
import jakarta.persistence.CascadeType
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.FetchType
import jakarta.persistence.Index
import jakarta.persistence.Inheritance
import jakarta.persistence.InheritanceType
import jakarta.persistence.JoinColumn
import jakarta.persistence.ManyToOne
import jakarta.persistence.OneToMany
import jakarta.persistence.Table
import org.amshove.kluent.shouldBeEmpty
import org.amshove.kluent.shouldBeEqualTo
import org.amshove.kluent.shouldContainAll
import org.amshove.kluent.shouldNotBeEmpty
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.repository.findByIdOrNull

class JoinedInheritanceTest: AbstractHibernateTest() {

    companion object: KLogging()

    @Autowired
    private val employeeRepo: JoinedEmployeeRepository = uninitialized()

    @Autowired
    private val customerRepo: JoinedCustomerRepository = uninitialized()

    @Test
    fun `inheritance with joined table`() {
        val emp1 = JoinedEmployee().apply {
            name = "Debop"
            ssn = "111111-111111"
            empNo = "004444"
        }
        val emp2 = JoinedEmployee().apply {
            name = "Kally"
            ssn = "222222-222222"
            empNo = "009999"
        }

        emp1.members.add(emp2)
        emp2.manager = emp1

        val customer = JoinedCustomer().apply {
            name = "Black"
            ssn = "333333-333333"
            mobile = "010-5555-5555"
        }
        customer.contactEmployee = emp2

        employeeRepo.save(emp1)
        customerRepo.save(customer)
        flushAndClear()

        val customer1 = customerRepo.findByIdOrNull(customer.id)!!
        customer1.contactEmployee shouldBeEqualTo emp2

        val employee1 = employeeRepo.findByIdOrNull(emp1.id)!!
        employee1 shouldBeEqualTo emp1
        employee1.members shouldContainAll setOf(emp2)

        // remove all members
        employee1.members.forEach { it.manager = null }
        employee1.members.clear()

        // emp2 만 남겨둔다
        employeeRepo.delete(employee1)
        customerRepo.delete(customer1)
        flushAndClear()

        employeeRepo.findAll().shouldNotBeEmpty()
        customerRepo.findAll().shouldBeEmpty()
    }
}

/**
 * Joined Table Inheritance
 *
 * ```sql
 * create table joined_person (
 *         id integer generated by default as identity,
 *         person_name varchar(128) not null,
 *         ssn varchar(128) not null,
 *         primary key (id)
 * );
 *
 * create index idx_joined_person_name
 *        on joined_person (person_name, ssn);
 * ```
 */
@Entity(name = "joined_person")
@Inheritance(strategy = InheritanceType.JOINED)
@Table(
    indexes = [
        Index(name = "idx_joined_person_name", columnList = "personName, ssn")
    ]
)
abstract class AbstractJoinedPerson: IntJpaEntity() {

    @Column(name = "personName", nullable = false, length = 128)
    var name: String = ""

    @Column(name = "ssn", nullable = false, length = 128)
    var ssn: String = ""

    override fun equalProperties(other: Any): Boolean =
        other is AbstractJoinedPerson && name == other.name && ssn == other.ssn

    override fun buildStringHelper(): ToStringBuilder {
        return super.buildStringHelper()
            .add("name", name)
            .add("ssn", ssn)
    }
}

/**
 * ```sql
 * create table joined_employee (
 *         emp_no varchar(12) not null,
 *         id integer not null,
 *         manager_id integer,
 *         primary key (id)
 * );
 *
 * create index idx_joined_employee_empno
 *        on joined_employee (emp_no);
 * ```
 */
@Entity(name = "joined_employee")
@Table(indexes = [Index(name = "idx_joined_employee_empno", columnList = "empNo")])
class JoinedEmployee: AbstractJoinedPerson() {

    @Column(name = "empNo", nullable = false, length = 12)
    var empNo: String = ""

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "manager_id")
    var manager: JoinedEmployee? = null

    @OneToMany(mappedBy = "manager", cascade = [CascadeType.ALL], fetch = FetchType.LAZY)
    val members: MutableSet<JoinedEmployee> = hashSetOf()

    override fun equalProperties(other: Any): Boolean =
        other is JoinedEmployee &&
                empNo == other.empNo &&
                super.equalProperties(other)

    override fun buildStringHelper(): ToStringBuilder {
        return super.buildStringHelper()
            .add("empNo", empNo)
    }
}

/**
 * ```sql
 * create table joined_customer (
 *         mobile varchar(16) not null,
 *         id integer not null,
 *         contact_emp_id integer,
 *         primary key (id)
 * );
 *
 * create index idx_joined_customer_mobile
 *        on joined_customer (mobile);
 * ```
 */
@Entity(name = "joined_customer")
@Table(indexes = [Index(name = "idx_joined_customer_mobile", columnList = "mobile")])
class JoinedCustomer: AbstractJoinedPerson() {

    @Column(name = "mobile", nullable = false, length = 16)
    var mobile: String = ""

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "contact_emp_id")
    var contactEmployee: JoinedEmployee? = null

    override fun equalProperties(other: Any): Boolean =
        other is JoinedCustomer &&
                mobile == other.mobile &&
                super.equalProperties(other)

    override fun buildStringHelper(): ToStringBuilder {
        return super.buildStringHelper()
            .add("mobile", mobile)
    }
}

interface JoinedEmployeeRepository: JpaRepository<JoinedEmployee, Int>
interface JoinedCustomerRepository: JpaRepository<JoinedCustomer, Int>
