package io.bluetape4k.hibernate.mapping.inheritance

import io.bluetape4k.ToStringBuilder
import io.bluetape4k.hibernate.AbstractHibernateTest
import io.bluetape4k.hibernate.model.IntJpaEntity
import io.bluetape4k.support.uninitialized
import jakarta.persistence.Column
import jakarta.persistence.DiscriminatorValue
import jakarta.persistence.Entity
import jakarta.persistence.Index
import jakarta.persistence.Inheritance
import jakarta.persistence.InheritanceType
import jakarta.persistence.Table
import org.amshove.kluent.shouldBeEmpty
import org.amshove.kluent.shouldBeEqualTo
import org.amshove.kluent.shouldNotBeEmpty
import org.hibernate.annotations.DynamicInsert
import org.hibernate.annotations.DynamicUpdate
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.repository.findByIdOrNull
import java.time.LocalDate

class SingleTableInheritanceTest: AbstractHibernateTest() {

    @Autowired
    private val creditCardRepo: SingleTableCreditCardRepository = uninitialized()

    @Autowired
    private val bankAccountRepo: SingleTableBankAccountRepository = uninitialized()

    @Test
    fun `single table with two type entities`() {
        val account = BankAccount("debop").apply {
            accountNumber = "123-456-7890"
            bankName = "Kookmin Bank"
            swift = "KODBKRSE"
        }

        bankAccountRepo.save(account)

        val card = CreditCard("debop").apply {
            number = "1234-5678-9012-3456"
            companyName = "VISA"
            expMonth = 12
            expYear = 2029
            startDate = LocalDate.now() //  Date.from(Instant.now())
        }
        creditCardRepo.save(card)

        flushAndClear()

        val account2 = bankAccountRepo.findByIdOrNull(account.id)!!
        account2 shouldBeEqualTo account

        val card2 = creditCardRepo.findByIdOrNull(card.id)!!
        card2 shouldBeEqualTo card

        bankAccountRepo.deleteAll()
        bankAccountRepo.flush()

        // 같은 테이블이지만, bank account의 모든 정보가 삭제되어도, credit card 정보는 남아있다
        creditCardRepo.findAll().shouldNotBeEmpty()

        creditCardRepo.deleteAll()
        flushAndClear()
        creditCardRepo.findAll().shouldBeEmpty()
    }
}

/**
 * Single Table Inheritance
 *
 * ```sql
 * create table singletable_billing (
 *         dtype varchar(31) not null,
 *         id integer generated by default as identity,
 *         owner varchar(255) not null,
 *         account_number varchar(255),
 *         bank_name varchar(255),
 *         swift varchar(255),
 *         company_name varchar(255),
 *         end_date date,
 *         exp_month integer,
 *         exp_year integer,
 *         number varchar(255),
 *         start_date date,
 *         primary key (id)
 *     )
 * ```
 */
@Entity(name = "singletable_billing")
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@Table(
    name = "singletable_billing",
    indexes = [
        Index(name = "ix_singletable_billing_owner", columnList = "owner")
    ]
)
abstract class AbstractBilling(
    @Column(nullable = false)
    var owner: String = "",
): IntJpaEntity() {

    override fun equalProperties(other: Any): Boolean =
        other is AbstractBilling && owner == other.owner

    override fun buildStringHelper(): ToStringBuilder {
        return super.buildStringHelper()
            .add("owner", owner)
    }
}

// NOTE: SingleTable 형식의 Entity의 모든 property는 nullable 이어야 합니다.

@Entity(name = "singletable_creditcard")
@DiscriminatorValue("CREDIT_CARD")
@DynamicInsert
@DynamicUpdate
class CreditCard(owner: String): AbstractBilling(owner) {

    var number: String? = null
    var companyName: String? = null
    var expMonth: Int? = null
    var expYear: Int? = null

    // @Temporal(TemporalType.TIMESTAMP)
    var startDate: LocalDate? = null

    // @Temporal(TemporalType.TIMESTAMP)
    var endDate: LocalDate? = null

    var swift: String? = null

    override fun equalProperties(other: Any): Boolean =
        other is CreditCard &&
                number == other.number &&
                super.equalProperties(other)

    override fun buildStringHelper(): ToStringBuilder {
        return super.buildStringHelper()
            .add("number", number)
            .add("companyName", companyName)
            .add("expMonth", expMonth)
            .add("expYear", expYear)
    }
}

// NOTE: SingleTable 형식의 Entity의 모든 property는 nullable 이어야 합니다.

@Entity(name = "singletable_bankaccount")
@DiscriminatorValue("BANK_ACCOUNT")
@DynamicInsert
@DynamicUpdate
class BankAccount(owner: String): AbstractBilling(owner) {
    var accountNumber: String? = null
    var bankName: String? = null
    var swift: String? = null

    override fun equalProperties(other: Any): Boolean =
        other is BankAccount &&
                accountNumber == other.accountNumber &&
                bankName == other.bankName &&
                super.equalProperties(other)

    override fun buildStringHelper(): ToStringBuilder {
        return super.buildStringHelper()
            .add("accountNumber", accountNumber)
            .add("bankName", bankName)
            .add("swift", swift)
    }
}

interface SingleTableCreditCardRepository: JpaRepository<CreditCard, Int>
interface SingleTableBankAccountRepository: JpaRepository<BankAccount, Int>
