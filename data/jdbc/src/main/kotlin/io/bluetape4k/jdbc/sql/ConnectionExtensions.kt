package io.bluetape4k.jdbc.sql

import io.bluetape4k.support.assertNotBlank
import java.sql.Connection
import java.sql.ResultSet
import java.sql.Statement

/**
 * 새로운 Statement를 생성하고 작업을 수행합니다.
 *
 * 이 함수는 Statement를 생성하고 제공된 블록에서 사용한 후 자동으로 닫습니다.
 *
 * ```kotlin
 * dataSource.connection.use { conn ->
 *     conn.withStatement { stmt ->
 *         stmt.executeQuery("SELECT * FROM actors")
 *     }
 * }
 * ```
 *
 * @param T 결과 타입
 * @param block Statement를 사용하여 결과를 가져오는 코드 블록
 * @return 조회한 결과
 */
inline fun <T> Connection.withStatement(block: (Statement) -> T): T =
    this.createStatement().use { stmt ->
        block(stmt)
    }

/**
 * SQL 쿼리를 실행하고 결과를 mapper를 통해 변환합니다.
 *
 * ```kotlin
 * val actors = dataSource.connection.runQuery("SELECT * FROM actors") { rs ->
 *     val actors = mutableListOf<Actor>()
 *     while (rs.next()) {
 *         actors.add(Actor(rs.getInt("id"), rs.getString("name")))
 *     }
 *     actors
 * }
 * ```
 *
 * @param T 결과 타입
 * @param sqlString 실행할 SQL 구문
 * @param mapper ResultSet을 결과 타입으로 변환하는 매퍼 함수
 * @return 변환된 결과
 */
inline fun <T> Connection.runQuery(
    sqlString: String,
    crossinline mapper: (ResultSet) -> T,
): T {
    sqlString.assertNotBlank("sqlString")

    return withStatement { stmt ->
        stmt.executeQuery(sqlString).use(mapper)
    }
}

/**
 * SQL 업데이트 문을 실행하고 영향받은 행 수를 반환합니다.
 *
 * ```kotlin
 * val count = dataSource.connection.executeUpdate("DELETE FROM actors WHERE id = 1")
 * ```
 *
 * @param sqlString 실행할 SQL 구문
 * @return 영향받은 행 수
 */
fun Connection.executeUpdate(sqlString: String): Int {
    sqlString.assertNotBlank("sqlString")

    return withStatement { stmt ->
        stmt.executeUpdate(sqlString)
    }
}

/**
 * SQL 업데이트 문을 실행하고 생성된 키를 포함한 결과를 반환합니다.
 *
 * ```kotlin
 * val id = dataSource.connection.executeUpdate(
 *     "INSERT INTO actors (name) VALUES ('Tom Hanks')",
 *     Statement.RETURN_GENERATED_KEYS
 * )
 * ```
 *
 * @param sqlString 실행할 SQL 구문
 * @param autoGeneratedKeys 자동 생성된 키 반환 옵션 (Statement.RETURN_GENERATED_KEYS 등)
 * @return 영향받은 행 수 또는 생성된 키 관련 정보
 */
fun Connection.executeUpdate(
    sqlString: String,
    autoGeneratedKeys: Int,
): Int {
    sqlString.assertNotBlank("sqlString")

    return withStatement { stmt ->
        stmt.executeUpdate(sqlString, autoGeneratedKeys)
    }
}

/**
 * SQL 업데이트 문을 실행하고 지정된 컬럼 인덱스의 생성된 키를 반환합니다.
 *
 * ```kotlin
 * val id = dataSource.connection.executeUpdate(
 *     "INSERT INTO actors (name) VALUES ('Tom Hanks')",
 *     intArrayOf(1)  // 첫 번째 컬럼의 생성된 키 반환
 * )
 * ```
 *
 * @param sqlString 실행할 SQL 구문
 * @param columnIndexes 생성된 키를 가져올 컬럼 인덱스들
 * @return 영향받은 행 수
 */
fun Connection.executeUpdate(
    sqlString: String,
    vararg columnIndexes: Int,
): Int {
    sqlString.assertNotBlank("sqlString")

    return withStatement { stmt ->
        stmt.executeUpdate(sqlString, columnIndexes)
    }
}

/**
 * SQL 업데이트 문을 실행하고 지정된 컬럼 레이블의 생성된 키를 반환합니다.
 *
 * ```kotlin
 * val id = dataSource.connection.executeUpdate(
 *     "INSERT INTO actors (name) VALUES ('Tom Hanks')",
 *     arrayOf("id")  // "id" 컬럼의 생성된 키 반환
 * )
 * ```
 *
 * @param sqlString 실행할 SQL 구문
 * @param columnLabels 생성된 키를 가져올 컬럼 레이블들
 * @return 영향받은 행 수
 */
fun Connection.executeUpdate(
    sqlString: String,
    vararg columnLabels: String,
): Int {
    sqlString.assertNotBlank("sqlString")

    return withStatement { stmt ->
        stmt.executeUpdate(sqlString, columnLabels)
    }
}

/**
 * SQL INSERT 문을 실행하고 생성된 키를 반환합니다.
 *
 * ```kotlin
 * val generatedId = connection.executeInsert(
 *     "INSERT INTO actors (name) VALUES ('Tom Hanks')"
 * ) { rs ->
 *     if (rs.next()) rs.getLong(1) else null
 * }
 * ```
 *
 * @param T 생성된 키의 타입
 * @param sqlString 실행할 SQL 구문
 * @param keyMapper 생성된 키 ResultSet을 매핑하는 함수
 * @return 생성된 키 또는 null
 */
inline fun <T> Connection.executeInsert(
    sqlString: String,
    crossinline keyMapper: (ResultSet) -> T,
): T? {
    sqlString.assertNotBlank("sqlString")

    return withStatement { stmt ->
        stmt.executeUpdate(sqlString, Statement.RETURN_GENERATED_KEYS)
        stmt.generatedKeys.use(keyMapper)
    }
}

/**
 * 여러 SQL 문을 배치로 실행합니다.
 *
 * ```kotlin
 * val results = connection.executeBatch(
 *     "INSERT INTO actors (name) VALUES ('Actor 1')",
 *     "INSERT INTO actors (name) VALUES ('Actor 2')",
 *     "INSERT INTO actors (name) VALUES ('Actor 3')"
 * )
 * ```
 *
 * @param sqlStrings 실행할 SQL 구문들
 * @return 각 SQL 문의 실행 결과 배열
 */
fun Connection.executeBatch(vararg sqlStrings: String): IntArray =
    withStatement { stmt ->
        sqlStrings.forEach { sql ->
            sql.assertNotBlank("sql")
            stmt.addBatch(sql)
        }
        stmt.executeBatch()
    }
