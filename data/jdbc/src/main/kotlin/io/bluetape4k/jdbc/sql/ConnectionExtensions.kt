package io.bluetape4k.jdbc.sql

import io.bluetape4k.support.assertNotBlank
import java.sql.Connection
import java.sql.ResultSet
import java.sql.Statement

/**
 * 새로운 [Statement]를 생성하고, 그 것을 이용하여 데이터를 조회합니다.
 *
 * ```
 * dataSource.connection.use { conn ->
 *     conn.withStatement { stmt ->
 *         stmt.verifyQuery(SELECT_ACTORS)
 *     }
 * }
 * ```
 *
 * @param T 결과 수형
 * @param block [Statement]를 사용하여 결과를 가져오는 코드 블럭
 * @return 조회한 결과
 */
inline fun <T> Connection.withStatement(block: (Statement) -> T): T =
    this.createStatement().use {
        block(it)
    }

/**
 * [sqlString]을 수행하고, 결과를 [mapper]를 통해 변환한 값을 반환합니다.
 *
 * ```
 * val actors = dataSource.connection.runQuery(SELECT_ACTORS) { rs ->
 *    val actors = mutableListOf<Actor>()
 *    while (rs.next()) {
 *      actors.add(Actor(rs.getInt("id"), rs.getString("name")))
 *    }
 * }
 * ```
 *
 * @param T    결과 수형
 * @param sqlString  실행할 sql 구문
 * @param mapper ResultSet을 결과 수형으로 변환하는 mapper
 * @return 변환된 결과
 */
inline fun <T> Connection.runQuery(sqlString: String, crossinline mapper: (ResultSet) -> T): T {
    sqlString.assertNotBlank("sqlString")
    
    return withStatement { stmt ->
        stmt.executeQuery(sqlString).use(mapper)
    }
}

/**
 * [sqlString]을 수행하고, 결과를 반환합니다.
 *
 * ```
 * val count = dataSource.connection.executeUpdate("DELETE FROM Actors")
 * ```
 *
 * @param sqlString 실행할 sql 구문
 * @param 영향 받은 행 수
 */
fun Connection.executeUpdate(sqlString: String): Int {
    sqlString.assertNotBlank("sqlString")
    
    return withStatement { stmt ->
        stmt.executeUpdate(sqlString)
    }
}

/**
 * [sqlString]을 수행하고, 결과를 반환합니다.
 *
 * ```
 * val id = dataSource.connection.executeUpdate(
 *      "INSERT INTO Actors (name) VALUES ('Tom Hanks')",
 *      Statement.RETURN_GENERATED_KEYS
 * )
 * ```
 *
 * @param sqlString 실행할 sql 구문
 * @param autoGeneratedKeys autoGeneratedKeys
 * @return 생성된 identifier 값
 */
fun Connection.executeUpdate(sqlString: String, autoGeneratedKeys: Int): Int {
    sqlString.assertNotBlank("sqlString")
    
    return withStatement { stmt ->
        stmt.executeUpdate(sqlString, autoGeneratedKeys)
    }
}

/**
 * [sqlString]을 수행하고, 결과를 반환합니다.
 *
 * ```
 * val id = dataSource.connection.executeUpdate(
 *     "INSERT INTO Actors (name) VALUES ('Tom Hanks')",
 *     1,
 * )
 * ```
 *
 * @param sqlString 실행할 sql 구문
 * @param columnIndexes columnIndexes
 * @return 생성된 identifier 값
 */
fun Connection.executeUpdate(sqlString: String, vararg columnIndexes: Int): Int {
    sqlString.assertNotBlank("sqlString")

    return withStatement { stmt ->
        stmt.executeUpdate(sqlString, columnIndexes)
    }
}

/**
 * [sqlString]을 수행하고, 결과를 반환합니다.
 *
 * ```
 * val id = dataSource.connection.executeUpdate(
 *    "INSERT INTO Actors (name) VALUES ('Tom Hanks')",
 *    "id"
 * )
 * ```
 *
 * @param sqlString 실행할 sql 구문
 * @param columnLabels columnLabels
 * @return 생성된 identifier 값
 */
fun Connection.executeUpdate(sqlString: String, vararg columnLabels: String): Int {
    sqlString.assertNotBlank("sqlString")

    return withStatement { stmt ->
        stmt.executeUpdate(sqlString, columnLabels)
    }
}
