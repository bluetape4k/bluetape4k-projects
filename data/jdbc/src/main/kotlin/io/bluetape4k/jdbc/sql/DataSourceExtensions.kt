package io.bluetape4k.jdbc.sql

import io.bluetape4k.support.assertNotBlank
import java.sql.Connection
import java.sql.ResultSet
import java.sql.Statement
import javax.sql.DataSource

/**
 * 새로운 Connection을 만들어서, 작업을 수행합니다.
 *
 * ```
 * val result = dataSource.withConnect { conn ->
 *    conn.prepareStatement("SELECT * FROM table").use { stmt ->
 *       stmt.executeQuery().use { rs ->
 *          // ResultSet 처리
 *          rs.getString("column")
 *          // ...
 *       }
 *    }
 * }
 * ```
 *
 * @param T 결과 수형
 * @param block 새로 연결한 [Connection]을 이용한 작업 코드 블럭
 * @return 작업 결과
 */
inline fun <T> DataSource.withConnect(crossinline block: (Connection) -> T): T {
    return connection?.use { conn ->
        block(conn)
    } ?: error("No connection returns from DataSource[$this]")
}

/**
 * 지정한 Statement 작업을 수행합니다.
 *
 * ```
 * val result = dataSource.withStatement { stmt ->
 *     stmt.executeUpdate("INSERT INTO table (column) VALUES ('value')")
 *     // ...
 * }
 *
 * @param T      결과 수형
 * @param block [Statement]를 수행하는 코드 블럭
 * @return 작업 결과
 */
inline fun <T> DataSource.withStatement(crossinline block: (Statement) -> T): T {
    return withConnect { conn ->
        conn.withStatement(block)
    }
}

/**
 * [sql] 구문을 실행하고, [mapper]를 이용하여 결과를 매핑합니다.
 *
 * ```
 * val result = dataSource.runQuery("SELECT * FROM table") { rs ->
 *    // ResultSet 처리
 *    rs.getString("column")
 * }
 * ```
 *
 * @param T      결과 수형
 * @param sql    실행할 SQL 구문
 * @param mapper [ResultSet]를 이용한 결과 매핑 코드
 */
inline fun <T> DataSource.runQuery(sql: String, crossinline mapper: (ResultSet) -> T): T {
    sql.assertNotBlank("sql")
    return withConnect { conn ->
        conn.runQuery(sql, mapper)
    }
}

/**
 * [sql] 구문을 [Connection.executeUpdate]을 이용하여 실행하고, 결과를 반환합니다.
 *
 * ```
 * val result = dataSource.executeUpdate("INSERT INTO table (column) VALUES ('value')")
 * ```
 *
 * @param sql 실행할 SQL 구문
 * @return 영향을 받은 행 수
 */
fun DataSource.executeUpdate(sql: String): Int {
    sql.assertNotBlank("sql")

    return withConnect { conn ->
        conn.executeUpdate(sql)
    }
}

/**
 * [sql] 구문을 [Connection.executeUpdate]을 이용하여 실행하고, [autoGeneratedKeys] 옵션에 따른 결과를 반환합니다.
 *
 * ```
 * val result = dataSource.executeUpdate(
 *      "INSERT INTO table (column) VALUES ('value')",
 *      Statement.RETURN_GENERATED_KEYS
 * )
 * ```
 *
 * @param sql             실행할 SQL 구문
 * @param autoGeneratedKeys 자동 생성된 키 반환 옵션
 * @return [autoGeneratedKeys] 옵션에 따른 결과
 */
fun DataSource.executeUpdate(sql: String, autoGeneratedKeys: Int): Int {
    sql.assertNotBlank("sql")
    return withConnect { conn ->
        conn.executeUpdate(sql, autoGeneratedKeys)
    }
}

/**
 * [sql] 구문을 [Connection.executeUpdate]을 이용하여 실행하고, [columnIndexes] 옵션에 따른 결과를 반환합니다.
 *
 * ```
 * val result = dataSource.executeUpdate(
 *     "INSERT INTO table (column) VALUES ('value')",
 *     1
 * )
 * ```
 *
 * @param sql          실행할 SQL 구문
 * @param columnIndexes 열 인덱스
 * @return [columnIndexes] 옵션에 따른 결과
 */
fun DataSource.executeUpdate(sql: String, vararg columnIndexes: Int): Int {
    sql.assertNotBlank("sql")
    return withConnect { conn ->
        conn.executeUpdate(sql, *columnIndexes)
    }
}

/**
 * [sql] 구문을 [Connection.executeUpdate]을 이용하여 실행하고, [columnLabels] 옵션에 따른 결과를 반환합니다.
 *
 * ```
 * val result = dataSource.executeUpdate(
 *    "INSERT INTO table (column) VALUES ('value')",
 *    "column"
 * )
 * ```
 *
 * @param sql         실행할 SQL 구문
 * @param columnLabels 열 레이블
 * @return [columnLabels] 옵션에 따른 결과
 */
fun DataSource.executeUpdate(sql: String, vararg columnLabels: String): Int {
    sql.assertNotBlank("sql")
    return withConnect { conn ->
        conn.executeUpdate(sql, *columnLabels)
    }
}
