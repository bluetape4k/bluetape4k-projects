package io.bluetape4k.jdbc.sql

import io.bluetape4k.support.assertNotBlank
import java.sql.Connection
import java.sql.ResultSet
import java.sql.Statement
import javax.sql.DataSource

/**
 * DataSource에서 새로운 Connection을 획득하여 작업을 수행합니다.
 *
 * 이 함수는 Connection을 획득하고 제공된 블록에서 사용한 후 자동으로 닫습니다.
 *
 * ```kotlin
 * val result = dataSource.withConnect { conn ->
 *     conn.prepareStatement("SELECT * FROM table").use { stmt ->
 *         stmt.executeQuery().use { rs ->
 *             // ResultSet 처리
 *             rs.getString("column")
 *         }
 *     }
 * }
 * ```
 *
 * @param T 결과 타입
 * @param block 새로 연결한 Connection을 이용한 작업 코드 블록
 * @return 작업 결과
 * @throws IllegalStateException Connection을 획득할 수 없을 경우
 */
inline fun <T> DataSource.withConnect(crossinline block: (Connection) -> T): T =
    connection?.use { conn ->
        block(conn)
    } ?: error("Failed to obtain connection from DataSource[$this]")

/**
 * DataSource에서 Statement를 생성하여 작업을 수행합니다.
 *
 * ```kotlin
 * val result = dataSource.withStatement { stmt ->
 *     stmt.executeUpdate("INSERT INTO table (column) VALUES ('value')")
 * }
 * ```
 *
 * @param T 결과 타입
 * @param block Statement를 수행하는 코드 블록
 * @return 작업 결과
 */
inline fun <T> DataSource.withStatement(crossinline block: (Statement) -> T): T =
    withConnect { conn ->
        conn.withStatement(block)
    }

/**
 * DataSource에서 SQL 쿼리를 실행하고 mapper를 이용하여 결과를 매핑합니다.
 *
 * ```kotlin
 * val result = dataSource.runQuery("SELECT * FROM table") { rs ->
 *     // ResultSet 처리
 *     rs.getString("column")
 * }
 * ```
 *
 * @param T 결과 타입
 * @param sql 실행할 SQL 구문
 * @param mapper ResultSet을 이용한 결과 매핑 코드
 * @return 매핑된 결과
 */
inline fun <T> DataSource.runQuery(
    sql: String,
    crossinline mapper: (ResultSet) -> T,
): T {
    sql.assertNotBlank("sql")
    return withConnect { conn ->
        conn.runQuery(sql, mapper)
    }
}

/**
 * DataSource에서 SQL 업데이트 문을 실행하고 결과를 반환합니다.
 *
 * ```kotlin
 * val result = dataSource.executeUpdate("INSERT INTO table (column) VALUES ('value')")
 * ```

 * @param sql 실행할 SQL 구문
 * @return 영향을 받은 행 수
 */
fun DataSource.executeUpdate(sql: String): Int {
    sql.assertNotBlank("sql")

    return withConnect { conn ->
        conn.executeUpdate(sql)
    }
}

/**
 * DataSource에서 SQL 업데이트 문을 실행하고 autoGeneratedKeys 옵션에 따른 결과를 반환합니다.
 *
 * ```kotlin
 * val result = dataSource.executeUpdate(
 *     "INSERT INTO table (column) VALUES ('value')",
 *     Statement.RETURN_GENERATED_KEYS
 * )
 * ```
 *
 * @param sql 실행할 SQL 구문
 * @param autoGeneratedKeys 자동 생성된 키 반환 옵션
 * @return autoGeneratedKeys 옵션에 따른 결과
 */
fun DataSource.executeUpdate(
    sql: String,
    autoGeneratedKeys: Int,
): Int {
    sql.assertNotBlank("sql")
    return withConnect { conn ->
        conn.executeUpdate(sql, autoGeneratedKeys)
    }
}

/**
 * DataSource에서 SQL 업데이트 문을 실행하고 columnIndexes 옵션에 따른 결과를 반환합니다.
 *
 * ```kotlin
 * val result = dataSource.executeUpdate(
 *     "INSERT INTO table (column) VALUES ('value')",
 *     intArrayOf(1)
 * )
 * ```
 *
 * @param sql 실행할 SQL 구문
 * @param columnIndexes 생성된 키를 가져올 컬럼 인덱스들
 * @return columnIndexes 옵션에 따른 결과
 */
fun DataSource.executeUpdate(
    sql: String,
    vararg columnIndexes: Int,
): Int {
    sql.assertNotBlank("sql")
    return withConnect { conn ->
        conn.executeUpdate(sql, *columnIndexes)
    }
}

/**
 * DataSource에서 SQL 업데이트 문을 실행하고 columnLabels 옵션에 따른 결과를 반환합니다.
 *
 * ```kotlin
 * val result = dataSource.executeUpdate(
 *     "INSERT INTO table (column) VALUES ('value')",
 *     arrayOf("id")
 * )
 * ```
 *
 * @param sql 실행할 SQL 구문
 * @param columnLabels 생성된 키를 가져올 컬럼 레이블들
 * @return columnLabels 옵션에 따른 결과
 */
fun DataSource.executeUpdate(
    sql: String,
    vararg columnLabels: String,
): Int {
    sql.assertNotBlank("sql")
    return withConnect { conn ->
        conn.executeUpdate(sql, *columnLabels)
    }
}

/**
 * DataSource에서 SQL INSERT 문을 실행하고 생성된 키를 반환합니다.
 *
 * ```kotlin
 * val generatedId = dataSource.executeInsert(
 *     "INSERT INTO actors (name) VALUES ('Tom Hanks')"
 * ) { rs ->
 *     if (rs.next()) rs.getLong(1) else null
 * }
 * ```
 *
 * @param T 생성된 키의 타입
 * @param sql 실행할 SQL 구문
 * @param keyMapper 생성된 키 ResultSet을 매핑하는 함수
 * @return 생성된 키 또는 null
 */
inline fun <T> DataSource.executeInsert(
    sql: String,
    crossinline keyMapper: (ResultSet) -> T,
): T? {
    sql.assertNotBlank("sql")
    return withConnect { conn ->
        conn.executeInsert(sql, keyMapper)
    }
}

/**
 * DataSource에서 여러 SQL 문을 배치로 실행합니다.
 *
 * ```kotlin
 * val results = dataSource.executeBatch(
 *     "INSERT INTO actors (name) VALUES ('Actor 1')",
 *     "INSERT INTO actors (name) VALUES ('Actor 2')",
 *     "INSERT INTO actors (name) VALUES ('Actor 3')"
 * )
 * ```
 *
 * @param sqlStrings 실행할 SQL 구문들
 * @return 각 SQL 문의 실행 결과 배열
 */
fun DataSource.executeBatch(vararg sqlStrings: String): IntArray =
    withConnect { conn ->
        conn.executeBatch(*sqlStrings)
    }
